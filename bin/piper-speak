#!/bin/bash
# piper-speak - Simple Piper TTS wrapper with chunking for large text
# Usage: echo "text" | piper-speak [--speed NUM] [--bg]
#        piper-speak "text to speak"
#
# Options:
#   --speed       Length scale (default: 0.7, lower = faster)
#   --bg          Run in background
#   --chunk-size  Max characters per chunk (default: 800)

PIPER_VOICE="${PIPER_VOICE:-en_US-lessac-medium}"
SPEED="0.7"
BACKGROUND=false
CHUNK_SIZE="${PIPER_CHUNK_SIZE:-800}"
TEXT=""

# Voice search paths (user dir first, then system)
USER_VOICE_DIR="${PIPER_VOICE_DIR:-$HOME/.local/share/piper/voices}"
SYSTEM_VOICE_DIR="/usr/share/piper-speak/voices"

# Session marker for stop signaling
SESSION_MARKER="/tmp/piper-speak-session"

while [[ $# -gt 0 ]]; do
    case $1 in
        --speed) SPEED="$2"; shift 2 ;;
        --bg) BACKGROUND=true; shift ;;
        --voice) PIPER_VOICE="$2"; shift 2 ;;
        --chunk-size) CHUNK_SIZE="$2"; shift 2 ;;
        --help|-h)
            echo "Usage: echo \"text\" | piper-speak [options]"
            echo "       piper-speak [options] \"text to speak\""
            echo ""
            echo "Options:"
            echo "  --speed NUM       Length scale (default: 0.7, lower = faster)"
            echo "  --bg              Run in background"
            echo "  --voice NAME      Voice model name (default: en_US-lessac-medium)"
            echo "  --chunk-size NUM  Max characters per chunk (default: 800)"
            echo ""
            echo "Environment:"
            echo "  PIPER_VOICE_DIR   User voice directory (default: ~/.local/share/piper/voices)"
            echo "  PIPER_VOICE       Default voice model name"
            echo "  PIPER_CHUNK_SIZE  Default chunk size"
            echo ""
            echo "Voice models are loaded from user dir first, then /usr/share/piper-speak/voices"
            echo ""
            echo "Text is automatically split into chunks to prevent CPU overload."
            echo "Remove $SESSION_MARKER to stop playback."
            exit 0
            ;;
        -*) echo "Unknown option: $1" >&2; exit 1 ;;
        *) TEXT="$1"; shift ;;
    esac
done

# Find voice model (check user dir first, then system)
if [ -f "$USER_VOICE_DIR/$PIPER_VOICE.onnx" ]; then
    VOICE_PATH="$USER_VOICE_DIR/$PIPER_VOICE.onnx"
elif [ -f "$SYSTEM_VOICE_DIR/$PIPER_VOICE.onnx" ]; then
    VOICE_PATH="$SYSTEM_VOICE_DIR/$PIPER_VOICE.onnx"
else
    echo "Error: Voice model not found: $PIPER_VOICE" >&2
    echo "Run 'piper-speak-install $PIPER_VOICE' to download it" >&2
    exit 1
fi

# Split text into chunks at sentence boundaries
split_into_chunks() {
    local text="$1"
    local max_size="$2"
    local chunk=""

    # Replace newlines with spaces, normalize whitespace
    text=$(echo "$text" | tr '\n' ' ' | sed 's/  */ /g')

    # Split on sentence boundaries (. ! ?) while respecting chunk size
    while [ -n "$text" ]; do
        if [ ${#text} -le $max_size ]; then
            # Remaining text fits in one chunk
            echo "$text"
            break
        fi

        # Find a good break point within chunk size
        chunk="${text:0:$max_size}"

        # Try to break at sentence end (. ! ?)
        local break_pos=-1
        local last_period=$(echo "$chunk" | grep -bo '\. ' | tail -1 | cut -d: -f1)
        local last_exclaim=$(echo "$chunk" | grep -bo '! ' | tail -1 | cut -d: -f1)
        local last_question=$(echo "$chunk" | grep -bo '? ' | tail -1 | cut -d: -f1)

        # Find the latest sentence boundary
        for pos in $last_period $last_exclaim $last_question; do
            [ -n "$pos" ] && [ "$pos" -gt "$break_pos" ] && break_pos=$pos
        done

        if [ $break_pos -gt 0 ]; then
            # Break after the punctuation
            echo "${text:0:$((break_pos + 1))}"
            text="${text:$((break_pos + 2))}"
        else
            # No sentence boundary found, break at word boundary
            local space_pos=$(echo "$chunk" | grep -bo ' ' | tail -1 | cut -d: -f1)
            if [ -n "$space_pos" ] && [ "$space_pos" -gt 0 ]; then
                echo "${text:0:$space_pos}"
                text="${text:$((space_pos + 1))}"
            else
                # No space found, just break at chunk size
                echo "$chunk"
                text="${text:$max_size}"
            fi
        fi

        # Trim leading whitespace
        text="${text#"${text%%[![:space:]]*}"}"
    done
}

# Check if we should stop
should_stop() {
    [ ! -f "$SESSION_MARKER" ]
}

speak_chunk() {
    local text="$1"
    local tmp_wav="/tmp/piper-speak-$$.wav"

    [ -z "$text" ] && return 0
    should_stop && return 1

    # Generate wav
    echo "$text" | piper-tts --model "$VOICE_PATH" --length_scale "$SPEED" \
        --output_file "$tmp_wav" >/dev/null 2>&1

    # Check again before playing
    if should_stop; then
        rm -f "$tmp_wav"
        return 1
    fi

    # Play and wait for completion
    pw-play "$tmp_wav" 2>/dev/null
    rm -f "$tmp_wav"

    return 0
}

speak() {
    local text="$1"

    [ -z "$text" ] && return

    # Create session marker (for stop signaling)
    echo $$ > "$SESSION_MARKER"

    # Collect all chunks first to avoid subshell issues
    local chunks=()
    while IFS= read -r chunk; do
        [ -n "$chunk" ] && chunks+=("$chunk")
    done < <(split_into_chunks "$text" "$CHUNK_SIZE")

    # Process chunks sequentially
    for chunk in "${chunks[@]}"; do
        speak_chunk "$chunk" || break
    done

    # Clean up session marker
    rm -f "$SESSION_MARKER"
}

# Get text from argument or stdin
if [ -z "$TEXT" ]; then
    TEXT=$(cat)
fi

if [ -z "$TEXT" ]; then
    echo "Error: No text provided" >&2
    exit 1
fi

if $BACKGROUND; then
    # Create session marker BEFORE forking (so speak-selection sees it immediately)
    # Only for background mode which supports toggle-to-stop
    echo $$ > "$SESSION_MARKER"
    speak "$TEXT" >/dev/null 2>&1 &
else
    speak "$TEXT"
fi
